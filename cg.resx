<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="rchcg_con.Text" xml:space="preserve">
    <value>                                                                 Practicals

1. Write a program to draw a straight line using DDA technique.

2. Write a program to draw a straight line using Bresenham’s technique.

3. Write a program to draw a circle using DDA technique.

4. Write a program to draw a Circle using Bresenham’s technique.

5. Write a program to draw a triangle to perform translation.

6. Write a program to draw a triangle to perform scaling.

7. Write a program to draw a triangle to perform Rotation.

8. Write a program to draw pie chart.

9. Write a program to draw Histogram.

10. Write a program to clip a triangle against a given window.

11. Write a program to animate a man walking with an umbrella.

12. Write a program to rotate an object from one end of the screen to the other end using 
      the built-in line and circle functions.</value>
  </data>
  <data name="rchcg1.Text" xml:space="preserve">
    <value>/** 1. Write a program to draw a straight line using DDA technique. **/

#include &lt;graphics.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;dos.h&gt;
void main( )
{
	float x,y,x1,y1,x2,y2,dx,dy,step;
	int i,gd=DETECT,gm;
	initgraph(&amp;gd,&amp;gm,"..\\bgi");
	printf("Enter the value of x1 and y1 : ");
	scanf("%f%f",&amp;x1,&amp;y1);
	printf("Enter the value of x2 and y2: ");
	scanf("%f%f",&amp;x2,&amp;y2);
	dx=abs(x2-x1);
	dy=abs(y2-y1);
	if(dx&gt;=dy)
		step=dx;
	else
		step=dy;
	dx=dx/step;
	dy=dy/step;
	x=x1;
	y=y1;
	i=1;
	while(i&lt;=step)
	{
		putpixel(x,y,5);
		x=x+dx;
		y=y+dy;
		i=i+1;
		delay(100);
	}
	closegraph();
}</value>
  </data>
  <data name="rchcg2.Text" xml:space="preserve">
    <value>/** 2. Write a program to draw a straight line using Bresenham’s technique. **/

#include&lt;stdio.h&gt;
#include&lt;graphics.h&gt;
void drawline(int x0, int y0, int x1, int y1)
{
    int dx, dy, p, x, y;
    dx=x1-x0;
    dy=y1-y0;
    x=x0;
    y=y0;
    p=2*dy-dx;
    while(x&lt;x1)
    {
        if(p&gt;=0)
        {
            putpixel(x,y,7);
            y=y+1;
            p=p+2*dy-2*dx;
        }
        else
        {
            putpixel(x,y,7);
            p=p+2*dy;
        }
        x=x+1;
    }
}
int main()
{
    int gdriver=DETECT, gmode, error, x0, y0, x1, y1;
    initgraph(&amp;gdriver, &amp;gmode, "..\\bgi");
    printf("Enter co-ordinates of first point: ");
    scanf("%d%d", &amp;x0, &amp;y0);
    printf("Enter co-ordinates of second point: ");
    scanf("%d%d", &amp;x1, &amp;y1);
    drawline(x0, y0, x1, y1);
    return 0;
}</value>
  </data>
  <data name="rchcg3.Text" xml:space="preserve">
    <value>/** 3. Write a program to draw a circle using DDA technique. **/

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;graphics.h&gt;
#include&lt;math.h&gt;
void main()
{
	int gdriver=DETECT,gmode,errorcode,tmp,i=1,rds;
	float st_x,st_y,x1,x2,y1,y2,ep;
	initgraph(&amp;gdriver,&amp;gmode,"..\\BGI");
	printf("Enter Radius:");
	scanf("%d",&amp;rds);
	while(rds&gt;pow(2,i))
	i++;
	ep=1/pow(2,i);
	x1=rds;  y1=0;
	st_x=rds; st_y=0;
	do
	{
		x2=x1+(y1*ep);
		y2=y1-(x2*ep);
		putpixel(x2+200,y2+200,10); 
		x1=x2;
		y1=y2;
	}while((y1-st_y)&lt;ep || (st_x-x1)&gt;ep);
	getch();
}</value>
  </data>
  <data name="rchcg4.Text" xml:space="preserve">
    <value>/** 4. Write a program to draw a Circle using Bresenham’s technique. **/

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt; 
#include &lt;graphics.h&gt; 
void drawCircle(int xc, int yc, int x, int y) 
{ 
	putpixel(xc+x, yc+y, RED); 
	putpixel(xc-x, yc+y, RED); 
	putpixel(xc+x, yc-y, RED); 
	putpixel(xc-x, yc-y, RED); 
	putpixel(xc+y, yc+x, RED); 
	putpixel(xc-y, yc+x, RED); 
	putpixel(xc+y, yc-x, RED); 
	putpixel(xc-y, yc-x, RED); 
} 
void circleBres(int xc, int yc, int r) 
{ 
	int x = 0, y = r; 
	int d = 3 - 2 * r; 
	while (y &gt;= x) 
	{ 
		drawCircle(xc, yc, x, y); 
		x++; 
		if (d &gt; 0) 
		{ 
			y--;  
			d = d + 4 * (x - y) + 10; 
		} 
		else
		d = d + 4 * x + 6; 
		drawCircle(xc, yc, x, y); 
		delay(50); 
	} 
} 
int main() 
{ 
	int xc = 50, yc = 50, r2 = 30; 
	int gd = DETECT, gm; 
	initgraph(&amp;gd, &amp;gm, "..\\bgi");  
	circleBres(xc, yc, r2);    
	return 0; 
} </value>
  </data>
  <data name="rchcg5.Text" xml:space="preserve">
    <value>/** 5. Write a program to draw a triangle to perform translation. **/

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;graphics.h&gt;
#include&lt;process.h&gt;
#include&lt;math.h&gt;
int x1,y1,x2,y2,x3,y3,mx,my;
void draw();
void tri();
void main()
{
	int gd=DETECT,gm;
	int c;
	initgraph(&amp;gd,&amp;gm,"..\\bgi ");
	printf("Enter the 1st point for the triangle:");
	scanf("%d%d",&amp;x1,&amp;y1);
	printf("Enter the 2nd point for the triangle:");
	scanf("%d%d",&amp;x2,&amp;y2);
	printf("Enter the 3rd point for the triangle:");
	scanf("%d%d",&amp;x3,&amp;y3);
	cleardevice();
	draw();
	getch();
	tri();
	getch();
}
void draw()
{
	line(x1,y1,x2,y2);
	line(x2,y2,x3,y3);
	line(x3,y3,x1,y1);
}
void tri()
{
	int x,y,a1,a2,a3,b1,b2,b3;
	printf("Enter the Transaction coordinates");
	scanf("%d%d",&amp;x,&amp;y);
	cleardevice();
	a1=x1+x;
	b1=y1+y;
	a2=x2+x;
	b2=y2+y;
	a3=x3+x;
	b3=y3+y;
	line(a1,b1,a2,b2);
	line(a2,b2,a3,b3);
	line(a3,b3,a1,b1);
}</value>
  </data>
  <data name="rchcg6.Text" xml:space="preserve">
    <value>/** 6. Write a program to draw a triangle to perform scaling. **/

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;graphics.h&gt;                                                                                                   
#include&lt;process.h&gt;
#include&lt;math.h&gt;
int x1,y1,x2,y2,x3,y3,mx,my;
void draw();
void scale();
void main()
{
	int gd=DETECT,gm;
	int c;
	initgraph(&amp;gd,&amp;gm,"..\\bgi");
	printf("Enter the 1st point for the triangle:");
	scanf("%d%d",&amp;x1,&amp;y1);
	printf("Enter the 2nd point for the triangle:");
	scanf("%d%d",&amp;x2,&amp;y2);
	printf("Enter the 3rd point for the triangle:");
	scanf("%d%d",&amp;x3,&amp;y3);
	draw();
	scale();
}
void draw()
{
	line(x1,y1,x2,y2);
	line(x2,y2,x3,y3);
	line(x3,y3,x1,y1);
}
void scale()
{
	int x,y,a1,a2,a3,b1,b2,b3;
	int mx,my;
	printf("Enter the scalling coordinates");
	scanf("%d%d",&amp;x,&amp;y);
	mx=(x1+x2+x3)/3;
	my=(y1+y2+y3)/3;
	cleardevice();
	a1=mx+(x1-mx)*x;
	b1=my+(y1-my)*y;
	a2=mx+(x2-mx)*x;
	b2=my+(y2-my)*y;
	a3=mx+(x3-mx)*x;
	b3=my+(y3-my)*y;
	line(a1,b1,a2,b2);
	line(a2,b2,a3,b3);
	line(a3,b3,a1,b1);
	draw();
	getch();
}</value>
  </data>
  <data name="rchcg7.Text" xml:space="preserve">
    <value>/** 7. Write a program to draw a triangle to perform Rotation. **/

#include &lt;graphics.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;iostream.h&gt;
#include &lt;math.h&gt;
float x1,y1,x2,y2,x,y,x3,y3,x4,y4,a;
int ch;
int main(void)
{
	int gdriver = DETECT, gmode, errorcode;
	clrscr();
	initgraph(&amp;gdriver, &amp;gmode, "..\\bgi");
	cout&lt;&lt;"enter coordinates of line1:\n";
	cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
	cout&lt;&lt;"enter coordinates for relative line:\n";
	cin&gt;&gt;x3&gt;&gt;y3;
	cout&lt;&lt;"enter the angle of rotation:\n";cin&gt;&gt;a;
	cleardevice();
	line(x1,y1,x2,y2);
	moveto(x2,y2);
	lineto(x3,y3);
	moveto(x3,y3);
	lineto(x1,y1);
	a=a*(3.14/180);
	x1=(x1*cos(a))-(y1*sin(a));
	y1=(x1*sin(a))+(y1*cos(a));
	x2=(x2*cos(a))-(y2*sin(a));
	y2=(x2*sin(a))+(y2*cos(a));
	x3=(x3*cos(a))-(y3*sin(a));
	y3=(x3*sin(a))+(y3*cos(a));
	cout&lt;&lt;"now hit a key to see rotation:";
	getch();
	moveto(x1,y1);
	lineto(x2,y2);
	moveto(x2,y2);
	lineto(x3,y3);
	moveto(x3,y3);
	lineto(x1,y1);
	getch();
	closegraph();
}</value>
  </data>
  <data name="rchcg8.Text" xml:space="preserve">
    <value>/** 8. Write a program to draw pie chart. **/

#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
int main()
{
	int gd = DETECT, gm, midx, midy;
	
	initgraph(&amp;gd, &amp;gm, "..\\BGI");
 
	setcolor(MAGENTA);
	rectangle(0,40,639,450);
	settextstyle(SANS_SERIF_FONT,HORIZ_DIR,2);
	setcolor(WHITE);
	outtextxy(275,10,"Pie Chart");
 
	midx = getmaxx()/2;
	midy = getmaxy()/2;
 
	setfillstyle(LINE_FILL,BLUE);
	pieslice(midx, midy, 0, 75, 100);
	outtextxy(midx+100, midy - 75, "20.83%");
 
	setfillstyle(XHATCH_FILL,RED);
	pieslice(midx, midy, 75, 225, 100);
	outtextxy(midx-175, midy - 75, "41.67%");
 
	setfillstyle(WIDE_DOT_FILL,GREEN);
	pieslice(midx, midy, 225, 360, 100);
	outtextxy(midx+75, midy + 75, "37.50%");
 
	getch();
	return 0;
}</value>
  </data>
  <data name="rchcg9.Text" xml:space="preserve">
    <value>/** 9. Write a program to draw Histogram **/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define SIZE 10
int main(void)
{
	// declare and initialize an array named n with size SIZE...
	int n[SIZE] = {19, 3, 15, 7, 11, 9, 13, 5, 17, 1};
	int i, j;
	
	// display the table header...
	printf("%s%13s%17s\n","Element/index", "Value", "Histogram");
	
	// do the iteration, outer for loop, read row by row...
	for(i=0; i &lt;= (SIZE-1); i++)
	{
		printf("%9d%15d ", i, n[i]);
	
		// inner for loop, for every row, read column by column and print the bar...
		for(j = 1; j&lt;= n[i]; j++)
		
		// print the 'bar', and repeat...
		printf("*");
	
		// go to new line for new row, and repeats...
		printf("\n");
	}
	return 0;
}</value>
  </data>
  <data name="rchcg10.Text" xml:space="preserve">
    <value>/** 10. Write a program to clip a triangle against a given window. **/

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;graphics.h&gt;
#include&lt;math.h&gt;
void clip(float,float,float);
int i,j=0,n;
int rx1,rx2,ry1,ry2;
float x1[8],y1[8];
void main()
{
	int gd=DETECT,gm;
	int i,n;
	float x[8],y[8],m;
	clrscr();
	initgraph(&amp;gd,&amp;gm,"..\\bgi");
	printf("coordinates for rectangle : ");
	scanf("%d%d%d%d",&amp;rx1,&amp;ry1,&amp;rx2,&amp;ry2);
	printf("no. of sides for polygon : ");
	scanf("%d",&amp;n);
	printf("coordinates : ");
	for(i=0;i&lt;n;i++)
	{
		scanf("%f%f",&amp;x[i],&amp;y[i]);
	}
	cleardevice();
	outtextxy(10,10,"Before clipping");
	outtextxy(10,470,"Press any key....");
	rectangle(rx1,ry1,rx2,ry2);
	for(i=0;i&lt;n-1;i++)
	line(x[i],y[i],x[i+1],y[i+1]);
	line(x[i],y[i],x[0],y[0]);
	getch();
	cleardevice();
	for(i=0;i&lt;n-1;i++)
	{
		m=(y[i+1]-y[i])/(x[i+1]-x[i]);
		clip(x[i],y[i],m);
		clip(x[i+1],y[i+1],m);
	}
	m=(y[i]-y[0])/(x[i]-x[0]);
	clip(x[i],y[i],m);
	clip(x[0],y[0],m);
	outtextxy(10,10,"After clipping");
	outtextxy(10,470,"Press any key....");
	rectangle(rx1,ry1,rx2,ry2);
	for(i=0;i&lt;j-1;i++)
	line(x1[i],y1[i],x1[i+1],y1[i+1]);
	getch();
}	

void clip(float e,float f,float m)
{
	while(e&lt;rx1&amp;&amp;e&gt;rx2&amp;&amp;f&lt;ry1&amp;&amp;f&gt;ry2)
	{
		if(e&lt;rx1)
		{
			f=f+(m*(rx1-e));
			e=rx1;
		}
		else if(e&gt;rx2)
		{
			f=f+(m*(rx2-e));
			e=rx2;
		}
		if(f&lt;ry1)
		{
			e=e+((ry1-f)/m);
			f=ry1;
		}
		else if(f&gt;ry2)
		{
			e=e+((ry2-f)/m);
			f=ry2;
		}
	}
	x1[j]=e;
	y1[j]=f;
	j++;
}</value>
  </data>
  <data name="rchcg11.Text" xml:space="preserve">
    <value>/** 11. Write a program to animate a man walking with an umbrella. **/

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;graphics.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;dos.h&gt;
void main()
{
	int gd=DETECT,gm;
	int rhx,rhy,j,i;
	clrscr();
	initgraph(&amp;gd,&amp;gm,”..\\BGI”);
	for(i=0;i&lt;500;i+=5)
	{
		line(20,380,580,380); //platform
		if(i%2==0)
		{
			line(25+i,380,35+i,340); //leftleg
			line(45+i,380,35+i,340);//right leg
			line(35+i,310,25+i,330);//left hand
			delay(20);
		}
		else
		{
			line(35+i,380,35+i,340);
			line(35+i,310,40+i,330);
			delay(20);
		}
		line(35+i,340,35+i,310); //body
		circle(35+i,300,10); //head
		line(35+i,310,50+i,330); // hand
		line(50+i,330,50+i,280); //umbrella stick
		line(15+i,280,85+i,280); //umbrella right

		arc(50+i,280,0,180,35); //umbrella body
		arc(55+i,330,180,360,5);//umbrella handle
		rhx=getmaxx();
		rhy=getmaxy();
		for(j=0;j&lt;100;j++)
		{
			outtextxy(random(rhx),random(rhy-50),”|”);
			
			setcolor(WHITE);
		}
		delay(150);
		cleardevice();
	}
	getch();
}</value>
  </data>
  <data name="rchcg12.Text" xml:space="preserve">
    <value>/** 12. Write a program to rotate an object from one end of the screen to the other end using the 
            built-in line and circle functions. **/

#include&lt;graphics.h&gt;
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;dos.h&gt;
#include&lt;conio.h&gt;
#include&lt;process.h&gt;
#define RADIUS 70
#define SPOKES 5
#define PI 3.141592
void draw_wheel(int x,int y,double theta,double angle);
void main()
{
	int gd=DETECT,gm,x,y,dir=1;
	double angle,tilt=0,theta;
	angle=PI/SPOKES;
	x=RADIUS;
	y=240;
	initgraph(&amp;gd,&amp;gm,"..\\bgi");
	setfillstyle(2,RED);
	bar3d(20,312,620,320,0,0);
	draw_wheel(x,y,tilt,angle);
	while(1)
	{
		delay(20);
		setcolor(BLACK);
		setfillstyle(1,BLACK);
		fillellipse(x,y,RADIUS+1,RADIUS+1);
		draw_wheel(x,y,tilt,angle);
		if((x+RADIUS)&gt;640)
		dir=-1;
		else if((x-RADIUS)&lt;0)
		dir=1;
		x+=dir;
		if(dir==1)
		tilt=tilt+0.01745329; //0.017 is=1 degree
		else
		tilt=tilt-0.01745329;
		if(kbhit())
		exit(0);
		setcolor(WHITE);
		setfillstyle(0,BLACK);
		fillellipse(x,y,RADIUS,RADIUS);
		draw_wheel(x,y,tilt,angle);
	}
}
void draw_wheel(int x,int y,double theta,double angle)
{
	int j,xp,yp;
	for(j=0;j&lt;SPOKES;j++)
	{
		xp=x+RADIUS*cos(theta);
		yp=y+RADIUS*sin(theta);
		line(x,y,xp,yp);
		xp=x+RADIUS*cos(theta+PI);
		yp=y+RADIUS*sin(theta+PI);
		line(x,y,xp+1,yp);
		theta=theta+angle;
	}
}</value>
  </data>
</root>